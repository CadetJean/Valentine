<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>For Halle ‚ù§Ô∏è</title>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        body {
            background-color: #fff0f5;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            text-align: center;
            overflow-x: hidden;
            overflow-y: auto;
        }

        .card {
            background: white;
            padding: clamp(20px, 5vw, 40px);
            border-radius: 30px;
            border: 4px solid #ff85a2;
            box-shadow: 0 10px 25px rgba(255, 133, 162, 0.3);
            z-index: 10;
            position: relative;
            max-width: 100%;
            width: 100%;
            max-width: 500px;
        }

        .bg-heart {
            position: fixed;
            color: rgba(255, 182, 193, 0.4);
            font-size: 20px;
            z-index: 1;
            animation: float 6s infinite ease-in-out;
            pointer-events: none;
        }

        @keyframes float {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
        }

        h1 { 
            color: #ff4d6d; 
            font-size: clamp(1.5rem, 6vw, 2.2rem);
            margin: 0 0 20px 0;
            line-height: 1.2;
        }

        .btn-group {
            margin-top: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 14px 28px;
            font-size: clamp(1rem, 4vw, 1.1rem);
            font-weight: bold;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            -webkit-appearance: none;
            touch-action: manipulation;
            min-width: 100px;
        }

        button:active {
            transform: scale(0.95);
        }

        #yesBtn { 
            background-color: #ff4d6d; 
            color: white;
        }
        
        #noBtn { 
            background-color: #ffb3c1; 
            color: white;
        }

        .confetti {
            position: fixed;
            top: -50px;
            font-size: 24px;
            animation: fall linear forwards;
            user-select: none;
            pointer-events: none;
        }

        @keyframes fall {
            to { transform: translateY(110vh) rotate(360deg); }
        }

        .calendar-btn {
            display: inline-block;
            margin-top: 20px;
            padding: 14px 24px;
            background-color: #ff4d6d;
            color: white;
            text-decoration: none;
            border-radius: 50px;
            font-weight: bold;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            box-shadow: 0 4px 10px rgba(255, 77, 109, 0.3);
            touch-action: manipulation;
        }

        .calendar-btn:active {
            transform: scale(0.95);
        }

        .love-message {
            margin-top: 25px;
            padding: clamp(15px, 4vw, 20px);
            background-color: #ffe6f0;
            border-radius: 15px;
            border: 2px solid #ffb3c1;
            color: #ff4d6d;
            font-size: clamp(0.85rem, 3.5vw, 0.95rem);
            line-height: 1.6;
            text-align: left;
        }

        .message-title {
            font-weight: bold;
            font-size: clamp(1rem, 4vw, 1.1rem);
            margin-bottom: 10px;
            text-align: center;
            color: #ff4d6d;
        }

        /* Particle Heart Canvas */
        #particleCanvas {
            margin: 15px auto;
            display: block;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        .love-text {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            color: #ff4d6d;
            font-weight: bold;
            margin-top: 10px;
            opacity: 0;
            animation: fadeIn 1s ease-in 4s forwards;
        }

        .love-text-after {
            font-size: clamp(1.5rem, 6vw, 2rem);
            color: #ff4d6d;
            font-weight: bold;
            margin: 20px 0;
            opacity: 0;
            animation: fadeIn 1s ease-in 0.5s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Heartbeat Monitor */
        .heartbeat-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            background: rgba(255, 240, 245, 0.9);
            border-top: 2px solid #ff85a2;
            z-index: 5;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #heartbeatCanvas {
            width: 100%;
            height: 100%;
        }

        .heartbeat-text {
            position: fixed;
            bottom: 10px;
            right: 20px;
            font-size: clamp(0.8rem, 3vw, 1rem);
            color: #ff4d6d;
            font-weight: bold;
            z-index: 6;
            font-family: 'Courier New', monospace;
        }

        /* iPhone 15 Pro specific adjustments */
        @supports (padding: max(0px)) {
            body {
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }
            
            .heartbeat-container {
                padding-bottom: env(safe-area-inset-bottom);
            }
        }
    </style>
</head>
<body>

    <div class="card" id="valentineCard">
        <h1>Halle, will you be my Valentine?</h1>
        <canvas id="particleCanvas"></canvas>
        <div class="love-text" id="loveText">I love you Halle ‚ù§Ô∏è</div>
        <div class="btn-group">
            <button id="yesBtn" onclick="accepted()">YES</button>
            <button id="noBtn" onclick="denied()">NO</button>
        </div>
    </div>

    <script>
        // Set canvas size based on device
        const canvas = document.getElementById('particleCanvas');
        const isMobile = window.innerWidth < 768;
        canvas.width = Math.min(400, window.innerWidth - 80);
        canvas.height = isMobile ? 220 : 280;

        let noClickCount = 0;
        const noBtn = document.getElementById('noBtn');
        const yesBtn = document.getElementById('yesBtn');
        
        const errorMessages = [
            "Halle, error 404: 'No' not found.",
            "Invalid selection. Please try again.",
            "System Overload: Only 'Yes' is supported.",
            "Critical Error: Clicking 'No' is physically impossible.",
            "Access Denied. Did you mean to click 'Yes'?"
        ];

        // Particle Heart Animation
        const ctx = canvas.getContext('2d');
        const particles = [];
        const heartPositions = [];
        let rotationX = 0; // Rotation around X-axis (vertical flip)
        let rotationY = 0; // Rotation around Y-axis (horizontal flip)
        
        // Function to check if a point is inside the heart shape
        function isInsideHeart(x, y, centerX, centerY, scale) {
            // Normalize coordinates
            const nx = (x - centerX) / scale;
            const ny = (y - centerY + (isMobile ? 10 : 20)) / scale;
            
            // Heart equation: (x^2 + y^2 - 1)^3 - x^2*y^3 <= 0
            const eq = Math.pow(nx * nx + ny * ny - 1, 3) - nx * nx * ny * ny * ny;
            return eq <= 0;
        }
        
        // Generate heart shape positions - both outline and filled
        const scale = isMobile ? 6 : 8;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Generate outline particles
        for (let t = 0; t < 2 * Math.PI; t += 0.05) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            heartPositions.push({
                x: x * scale,
                y: y * scale - (isMobile ? 10 : 20),
                z: 0
            });
        }
        
        // Generate filled particles
        const gridSize = 8;
        for (let x = centerX - 140; x < centerX + 140; x += gridSize) {
            for (let y = centerY - 140; y < centerY + 60; y += gridSize) {
                if (isInsideHeart(x, y, centerX, centerY, scale)) {
                    // Convert to relative coordinates
                    heartPositions.push({
                        x: (x - centerX) + Math.random() * gridSize,
                        y: (y - centerY) + Math.random() * gridSize,
                        z: 0
                    });
                }
            }
        }

        class Particle {
            constructor(targetX, targetY, targetZ, delay) {
                this.x = canvas.width / 2 + (Math.random() - 0.5) * 100;
                this.startY = canvas.height + 20;
                this.y = this.startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.targetZ = targetZ;
                this.size = Math.random() * 2.5 + 1.5;
                this.delay = delay;
                this.elapsed = 0;
                this.duration = 2000 + Math.random() * 1000;
                this.color = `hsl(${330 + Math.random() * 30}, 100%, ${60 + Math.random() * 20}%)`;
                this.currentX = this.x;
                this.currentY = this.y;
                this.currentZ = 0;
            }

            update(deltaTime) {
                if (this.elapsed < this.delay) {
                    this.elapsed += deltaTime;
                    return;
                }

                const progress = Math.min((this.elapsed - this.delay) / this.duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                // Calculate position based on progress
                const tempY = this.startY + (this.targetY - this.startY) * easeProgress;
                const tempX = this.x + (this.targetX - this.x) * easeProgress * 0.1;
                
                // Apply 3D rotation
                const relX = this.targetX;
                const relY = this.targetY;
                const relZ = this.targetZ;
                
                // Rotation around Y-axis (left-right flip)
                const cosY = Math.cos(rotationY);
                const sinY = Math.sin(rotationY);
                const rotatedX = relX * cosY - relZ * sinY;
                const rotatedZ1 = relX * sinY + relZ * cosY;
                
                // Rotation around X-axis (up-down flip)
                const cosX = Math.cos(rotationX);
                const sinX = Math.sin(rotationX);
                const rotatedY = relY * cosX - rotatedZ1 * sinX;
                const rotatedZ2 = relY * sinX + rotatedZ1 * cosX;
                
                // Apply perspective (simple perspective projection)
                const perspective = 300;
                const scale = perspective / (perspective + rotatedZ2);
                
                this.currentX = centerX + rotatedX * scale;
                this.currentY = centerY + rotatedY * scale;
                this.currentScale = scale;
                
                // Blend between rising animation and final rotated position
                if (progress < 1) {
                    this.currentX = tempX + (this.currentX - tempX) * progress;
                    this.currentY = tempY + (this.currentY - tempY) * progress;
                }
                
                this.elapsed += deltaTime;
            }

            draw() {
                if (this.elapsed < this.delay) return;
                
                const drawSize = this.size * (this.currentScale || 1);
                
                ctx.beginPath();
                ctx.arc(this.currentX, this.currentY, drawSize, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Glow effect
                ctx.shadowBlur = 8 * (this.currentScale || 1);
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Create particles
        heartPositions.forEach((pos, i) => {
            particles.push(new Particle(pos.x, pos.y, pos.z, i * 5));
        });

        let lastTime = Date.now();
        let rotationSpeedX = 0.0015; // Rotation speed around X-axis
        let rotationSpeedY = 0.0012; // Rotation speed around Y-axis
        let targetRotationSpeedX = 0.0006; // Slower speed after filling
        let targetRotationSpeedY = 0.0005; // Slower speed after filling

        function animateParticles() {
            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Check if all particles have reached their targets
            const allParticlesSettled = particles.every(p => p.elapsed >= p.delay + p.duration);
            
            // Gradually slow down rotation after particles settle
            if (allParticlesSettled) {
                rotationSpeedX += (targetRotationSpeedX - rotationSpeedX) * 0.02;
                rotationSpeedY += (targetRotationSpeedY - rotationSpeedY) * 0.02;
            }
            
            rotationX += rotationSpeedX * deltaTime;
            rotationY += rotationSpeedY * deltaTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach(particle => {
                particle.update(deltaTime);
                particle.draw();
            });

            requestAnimationFrame(animateParticles);
        }

        animateParticles();

        function denied() {
            alert(errorMessages[noClickCount % errorMessages.length]);
            noBtn.innerText = "Invalid ‚ùå";
            let currentSize = parseFloat(window.getComputedStyle(yesBtn).fontSize);
            yesBtn.style.fontSize = (currentSize + 10) + "px";
            yesBtn.style.padding = (parseFloat(window.getComputedStyle(yesBtn).padding) + 8) + "px";
            noClickCount++;
        }

        function createHeart() {
            const heart = document.createElement('div');
            heart.classList.add('confetti');
            heart.innerText = ['üíñ', 'üíó', 'üíì', 'üíï', 'üê∂'][Math.floor(Math.random() * 5)];
            heart.style.left = Math.random() * 100 + "vw";
            heart.style.animationDuration = (Math.random() * 2 + 3) + "s";
            document.body.appendChild(heart);
            setTimeout(() => heart.remove(), 5000);
        }

        function createHeartbeatMonitor() {
            // Create heartbeat monitor container
            const container = document.createElement('div');
            container.className = 'heartbeat-container';
            
            const heartbeatCanvas = document.createElement('canvas');
            heartbeatCanvas.id = 'heartbeatCanvas';
            heartbeatCanvas.width = window.innerWidth;
            heartbeatCanvas.height = 150;
            
            const heartbeatText = document.createElement('div');
            heartbeatText.className = 'heartbeat-text';
            heartbeatText.innerHTML = '‚ô• 120 BPM';
            
            container.appendChild(heartbeatCanvas);
            document.body.appendChild(container);
            document.body.appendChild(heartbeatText);
            
            // Animate heartbeat line
            const hbCtx = heartbeatCanvas.getContext('2d');
            let offset = 0;
            let beatPhase = 0;
            
            function drawHeartbeat() {
                hbCtx.clearRect(0, 0, heartbeatCanvas.width, heartbeatCanvas.height);
                
                // Grid lines
                hbCtx.strokeStyle = 'rgba(255, 133, 162, 0.2)';
                hbCtx.lineWidth = 1;
                for (let i = 0; i < heartbeatCanvas.height; i += 20) {
                    hbCtx.beginPath();
                    hbCtx.moveTo(0, i);
                    hbCtx.lineTo(heartbeatCanvas.width, i);
                    hbCtx.stroke();
                }
                for (let i = 0; i < heartbeatCanvas.width; i += 20) {
                    hbCtx.beginPath();
                    hbCtx.moveTo(i, 0);
                    hbCtx.lineTo(i, heartbeatCanvas.height);
                    hbCtx.stroke();
                }
                
                // Heartbeat line
                hbCtx.strokeStyle = '#ff4d6d';
                hbCtx.lineWidth = 3;
                hbCtx.beginPath();
                
                const centerY = heartbeatCanvas.height / 2;
                const beatInterval = 200; // Distance between beats
                
                for (let x = 0; x < heartbeatCanvas.width; x++) {
                    const adjustedX = x + offset;
                    const beatPos = adjustedX % beatInterval;
                    
                    let y = centerY;
                    
                    // ECG waveform pattern
                    if (beatPos < 10) {
                        // P wave (small bump before main spike)
                        y = centerY - Math.sin((beatPos / 10) * Math.PI) * 10;
                    } else if (beatPos >= 20 && beatPos < 25) {
                        // Q wave (small dip)
                        y = centerY + 8;
                    } else if (beatPos >= 25 && beatPos < 35) {
                        // R wave (main spike)
                        const progress = (beatPos - 25) / 10;
                        if (progress < 0.5) {
                            y = centerY - (progress * 2) * 60;
                        } else {
                            y = centerY - ((1 - progress) * 2) * 60;
                        }
                    } else if (beatPos >= 35 && beatPos < 40) {
                        // S wave (small dip after spike)
                        y = centerY + 12;
                    } else if (beatPos >= 50 && beatPos < 70) {
                        // T wave (recovery wave)
                        y = centerY - Math.sin(((beatPos - 50) / 20) * Math.PI) * 15;
                    }
                    
                    if (x === 0) {
                        hbCtx.moveTo(x, y);
                    } else {
                        hbCtx.lineTo(x, y);
                    }
                }
                
                hbCtx.stroke();
                
                // Glow effect
                hbCtx.shadowBlur = 10;
                hbCtx.shadowColor = '#ff4d6d';
                hbCtx.stroke();
                hbCtx.shadowBlur = 0;
                
                offset += 3; // Speed of the line moving
                if (offset > beatInterval) {
                    offset = 0;
                }
                
                requestAnimationFrame(drawHeartbeat);
            }
            
            drawHeartbeat();
        }

        function accepted() {
            const eventTitle = encodeURIComponent("Valentine's Dinner at Jean's");
            const eventDetails = encodeURIComponent("Menu: Pasta & Wine üçùüç∑\nEvening Plans: S'mores & relaxing! üî•");
            const calendarLink = `https://www.google.com/calendar/render?action=TEMPLATE&text=${eventTitle}&dates=20260214T233000Z/20260215T030000Z&details=${eventDetails}&location=Jean's+Place`;
            
            document.getElementById('valentineCard').innerHTML = `
                <div style="font-size: clamp(40px, 12vw, 60px);">üçùüç∑‚ú®</div>
                <h1 style="color: #ff4d6d;">It's a Date, Halle!</h1>
                <div class="love-text-after">I love you Halle ‚ù§Ô∏è</div>
                <a href="${calendarLink}" target="_blank" class="calendar-btn">üìÖ Add Dinner to Calendar</a>
                
                <div class="love-message">
                    <div class="message-title">"Every day with you is my favorite adventure"</div>
                    This means that life with you isn't just a routine, but a constant journey full of discovery and joy. It implies that no matter where we are or what we are doing, whether we're out on a trip or just relaxing at home, being by your side is what makes the experience meaningful. It frames our relationship as an ongoing story where the best parts are the moments we share together, making even the simplest days feel like a special destination.
                </div>
                
                <div style="font-size: clamp(10px, 2.5vw, 12px); margin-top: 20px; color: #ffb3c1;">From Jean Cadet</div>
            `;
            document.body.style.backgroundColor = "#ffc1cf";
            setInterval(createHeart, 150);
            createHeartbeatMonitor();
        }

        setInterval(() => {
            const bh = document.createElement('div');
            bh.classList.add('bg-heart');
            bh.innerHTML = '‚ù§Ô∏è';
            bh.style.left = Math.random() * 100 + 'vw';
            bh.style.bottom = '-5vh';
            bh.style.fontSize = (Math.random() * 15 + 10) + 'px';
            document.body.appendChild(bh);
            setTimeout(() => bh.remove(), 6000);
        }, 500);

        // Prevent zoom on double tap
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>
